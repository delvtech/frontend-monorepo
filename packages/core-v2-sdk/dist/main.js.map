{"mappings":"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","sources":["packages/core-v2-sdk/src/index.ts","packages/core-v2-sdk/src/utils/index.ts","packages/core-v2-sdk/src/utils/buyYieldTokens/buyYieldTokens.ts","packages/core-v2-sdk/src/utils/calcSwapCongergentCurvePool/calculateTradePrincipalTokens.ts","packages/core-v2-sdk/src/utils/calculateLPTokensOut/calculateLPTokensOut.ts","packages/core-v2-sdk/src/utils/provideLiquidity/provideLiquidity.ts","packages/core-v2-sdk/src/utils/redeemLiquidity/redeemLiquidity.ts","packages/core-v2-sdk/src/utils/tradePrincipalTokens/tradePrincipalTokens.ts","packages/core-v2-sdk/src/utils/withdrawLiquidity/withdrawLiquidity.ts"],"sourcesContent":["export * from './utils'","export * from \"./buyYieldTokens/buyYieldTokens\";\r\nexport * from \"./calcSwapCongergentCurvePool/calculateTradePrincipalTokens\";\r\nexport * from \"./calculateLPTokensOut/calculateLPTokensOut\";\r\nexport * from \"./provideLiquidity/provideLiquidity\";\r\nexport * from \"./redeemLiquidity/redeemLiquidity\";\r\nexport * from \"./tradePrincipalTokens/tradePrincipalTokens\";\r\nexport * from \"./withdrawLiquidity/withdrawLiquidity\";\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * A method to buy yield tokens.  Unclear at this point if this is simply performing the internal flashloan to perform a YTC.\r\n * @param tokenAddress\r\n * @param vaultAddress\r\n * @param amount\r\n * @param signer\r\n * @param overrides\r\n * @returns\r\n */\r\nexport async function buyYieldTokens(\r\n  tokenAddress: string,\r\n  vaultAddress: string,\r\n  amount: BigNumberish,\r\n  signer: Signer,\r\n  overrides: Overrides = {},\r\n): Promise<ContractTransaction> {\r\n  const signerAddress = await signer.getAddress();\r\n\r\n  return {\r\n    hash: \"0x00\",\r\n    from: signerAddress,\r\n    gasLimit: BigNumber.from(100),\r\n    data: \"0x\",\r\n    value: BigNumber.from(amount),\r\n    confirmations: 1,\r\n    chainId: 1,\r\n    nonce: 1,\r\n    wait: async () => Promise.resolve({} as unknown as ContractReceipt),\r\n  };\r\n}\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * calculates a trade of prinicipal tokens\r\n * this is likely to get a lot more complicated with swap kinds, exact in, exact out etc\r\n * @param tokenAmountsIn\r\n * @param tokenReserves\r\n * @returns\r\n */\r\nexport function calcSwapConvergentCurvePool(\r\n  tokenAmountsIn: BigNumberish[],\r\n  tokenReserves: BigNumberish[],\r\n): string {\r\n  return \"1\";\r\n}\r\n","import { BigNumberish } from \"ethers\";\r\n\r\n/**\r\n * calculates an amount of LP tokens out for an amount of asset provided.  could be single sided or double sided.\r\n * this one is likely to get a lot more complicated.  there could be join kinds like exact amount in, exact amount out etc.\r\n * @param tokenAmountsIn\r\n * @param tokenReserves\r\n * @returns\r\n */\r\nexport function calculateLPTokensOut(\r\n  tokenAmountsIn: BigNumberish[],\r\n  tokenReserves: BigNumberish[],\r\n): string {\r\n  return \"1\";\r\n}\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * A function to provide liquidity to a v2 term\r\n * @param tokensInAddresses\r\n * @param amounts\r\n * @param vaultAddress\r\n * @param slippage\r\n * @param signer\r\n * @param overrides\r\n * @returns\r\n */\r\nexport async function provideLiquidity(\r\n  amounts: BigNumberish[],\r\n  tokensInAddresses: string[],\r\n  vaultAddress: string,\r\n  slippage: BigNumberish,\r\n  signer: Signer,\r\n  overrides: Overrides = {},\r\n): Promise<ContractTransaction> {\r\n  const signerAddress = await signer.getAddress();\r\n\r\n  return {\r\n    hash: \"0x00\",\r\n    from: signerAddress,\r\n    gasLimit: BigNumber.from(100),\r\n    data: \"0x\",\r\n    value: BigNumber.from(amounts[0]),\r\n    confirmations: 1,\r\n    chainId: 1,\r\n    nonce: 1,\r\n    wait: async () => Promise.resolve({} as unknown as ContractReceipt),\r\n  };\r\n}\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * redeem liquidity after the term is mature to the underlying\r\n * @param amount\r\n * @param poolAddress\r\n * @param signer\r\n * @param overrides\r\n * @returns\r\n */\r\nexport async function redeemLiquidity(\r\n  amount: BigNumberish,\r\n  poolAddress: string,\r\n  signer: Signer,\r\n  overrides: Overrides = {},\r\n): Promise<ContractTransaction> {\r\n  const signerAddress = await signer.getAddress();\r\n\r\n  return {\r\n    hash: \"0x00\",\r\n    from: signerAddress,\r\n    gasLimit: BigNumber.from(100),\r\n    data: \"0x\",\r\n    value: BigNumber.from(amount),\r\n    confirmations: 1,\r\n    chainId: 1,\r\n    nonce: 1,\r\n    wait: async () => Promise.resolve({} as unknown as ContractReceipt),\r\n  };\r\n}\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * performs a trade of principal tokens on a v2 pool\r\n * this is likely to get a lot more complicated with swap kinds, exact in, exact out etc\r\n * @param tokenInAddress\r\n * @param tokenOutAddress\r\n * @param vaultAddress\r\n * @param amount\r\n * @param slippage\r\n * @param signer\r\n * @param overrides\r\n * @returns\r\n */\r\nexport async function tradePrincipalTokens(\r\n  amount: BigNumberish,\r\n  tokenInAddress: string,\r\n  tokenOutAddress: string,\r\n  vaultAddress: string,\r\n  slippage: BigNumberish,\r\n  signer: Signer,\r\n  overrides: Overrides = {},\r\n): Promise<ContractTransaction> {\r\n  const signerAddress = await signer.getAddress();\r\n\r\n  return {\r\n    hash: \"0x00\",\r\n    from: signerAddress,\r\n    gasLimit: BigNumber.from(100),\r\n    data: \"0x\",\r\n    value: BigNumber.from(amount),\r\n    confirmations: 1,\r\n    chainId: 1,\r\n    nonce: 1,\r\n    wait: async () => Promise.resolve({} as unknown as ContractReceipt),\r\n  };\r\n}\r\n","import {\r\n  BigNumber,\r\n  BigNumberish,\r\n  ContractReceipt,\r\n  ContractTransaction,\r\n  Overrides,\r\n  Signer,\r\n} from \"ethers\";\r\n\r\n/**\r\n * withdraw liquidity before the term is expired to underlying and pts\r\n * @param amount\r\n * @param poolAddress\r\n * @param signer\r\n * @param overrides\r\n * @returns\r\n */\r\nexport async function withdrawLiquidity(\r\n  amount: BigNumberish,\r\n  poolAddress: string,\r\n  signer: Signer,\r\n  overrides: Overrides = {},\r\n): Promise<ContractTransaction> {\r\n  const signerAddress = await signer.getAddress();\r\n\r\n  return {\r\n    hash: \"0x00\",\r\n    from: signerAddress,\r\n    gasLimit: BigNumber.from(100),\r\n    data: \"0x\",\r\n    value: BigNumber.from(amount),\r\n    confirmations: 1,\r\n    chainId: 1,\r\n    nonce: 1,\r\n    wait: async () => Promise.resolve({} as unknown as ContractReceipt),\r\n  };\r\n}\r\n"],"names":[],"version":3,"file":"main.js.map"}