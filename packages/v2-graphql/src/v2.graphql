# {
#   multiTerm(0xyvUSDC....): {
#     tvl
#     terms {
#       ...
#     }
#   }

#   ----> { data: {
#      multiTerm: {
#        tvl: '5,000,000',
#        terms: [{ ...}, {... }]
#        }
#     }
type Query {
  "Look up the multi term contract for a given yield source, eg: Yearn USDC Vault"
  multiTerm(yieldSource: ID!): MultiTerm
  term(yieldSource: ID!, maturity: String!): Term

  "Look up the pool for a given maturity date"
  pool(term: ID!, maturity: String!): Pool
  terms(yieldSource: ID!): [Term]
}

type MultiTerm {
  "general lookup across terms for arbitrary helper functions, to be expanded"
  address: ID!
  "The underlying token, sometimes referred to as base asset"
  baseAsset: Token
  "Possibly fetched from a registry"
  yieldSource: YieldSource
  "pretty sure these are useful"
  terms: [Term]
  tvl(atBlock: Int): String

  "scratch space: are these useful?"
  totalVolume: String
  perDayVolume: String
  yields: [String]
}

type Term {
  id: ID!
  name: String!
  "Timestamp in milliseconds since unix epoch"
  maturity: String!
  baseAsset: Token
  principalToken: PrincipalToken
  "startDate must be between created and maturity"
  yieldToken(startDate: String!): YieldToken
  pool: Pool
  "Possibly fetched from a registry"
  yieldSource: YieldSource
  "Dollar amount of deposits into the term: union(mint,LP)"
  tvl: String
  "Timestamp in milliseconds since unix epoch"
  createdTimestamp: Int
  "Block Int the term was created at"
  createdAtBlock: Int
}

type YieldToken {
  tokenId: ID!
  startDate: String!
  maturity: String!
  accruedInterest: String
}

type PrincipalToken {
  tokenId: ID!
  maturity: String!
  "price in terms of base asset or fiat"
  price: String
  priceFiat: String
  " the token this principal token will resolve 1 to 1 to."
  baseAsset: Token
}

type MultiPool {
  poolId: ID!
  pools(...filter args...): [Pool]
  pool(maturity: String!): Pool
}

type Pool {
  tokenId: ID!
  maturity: String!
  "price in terms of base asset or fiat"
  price: String
  priceFiat: String
  "the token this principal token will resolve 1 to 1 to."
  baseAsset: Token
  term: Term
  tvl: String
  swapInPreview(baseAssetIn: String!): SwapPreview!
  swapOutPreview(principalTokenIn: String!): SwapPreview!
}

type SwapPreview {
  baseAsset: String!
  principalTokenIn: String!
  slippage: Int
}

type YieldSource {
  "Yearn"
  name: ID!
}

# type PositionMultiTerm {
#   "MultiTerm address"
#   address: ID!
#   "address of the underlying position, eg: yearn vault usdc"
#   position: ID!
#   "Name of the yield source, eg: Yearn Vault Dai v2"
#   name: String!
#   protocol: Protocol
#   "APY of the underlying yield source"
#   apy: Int
#   "TVL of the yield source (in dollars)"
#   tvl: Int
#   "Get the price of a vault token in terms of any of the base assets"
#   pricePerShare(tokenOut: String!): String
#   pricePerShares(tokensOut: [String!]): [String]
#   baseAsset: Token
#   terms: [Term]
# }

type Token {
  address: ID!
  symbol: String!
  decimals: Int
  price: String
}

# type Pool {
#   address: ID!
#   position: YieldSource!

#   "Dollar amount traded in the pool"
#   tradingVolume(fromBlock: Int, toBlock: Int): String

#   "Dollar amount in fees accumulated on trades"
#   fees(fromBlock: Int, toBlock: Int): String
#   "Price of bond asset in terms of share asset, eg: 0.95 USDC for 1 ptUSDC"
#   spotPrice(atBlock: Int): String

#   "Num of principal or umbrella tokens"
#   bondReserves: Int!
#   "Num of base asset tokens"
#   shareReserves: Int!
#   timeStretch: String!

#   "num milliseconds until term maturity"
#   timeUntilMaturity: Int!

#   totalSupply: String!
#   initialPricePerShare: String!
#   currentPricePerShare: String!
# }
